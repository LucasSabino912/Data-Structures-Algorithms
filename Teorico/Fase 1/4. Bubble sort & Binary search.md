# Bubble sort & binary search

# Bubble sort

### Funcionamiento del Bubble Sort:

1. **Comparación de Elementos Adyacentes**:
    - Se comparan pares de elementos adyacentes en el array.
    - Si un elemento es mayor que el siguiente, se intercambian sus posiciones.
2. **Iteración Múltiple**:
    - Este proceso se repite varias veces, moviéndose por el array, hasta que no se necesiten más intercambios.
    - Con cada iteración completa, el siguiente mayor elemento "burbujea" hasta su posición correcta al final del array.
3. **Optimización (Salida Anticipada)**:
    - Si en una pasada no se realiza ningún intercambio, el array ya está ordenado y se puede salir del bucle anticipadamente.

### Características del Bubble Sort:

- **Complejidad Temporal**: Tiene una complejidad de tiempo de O(n2) tanto en el mejor como en el peor caso para la mayoría de las implementaciones, lo que lo hace ineficiente para grandes conjuntos de datos.
    
    O(n2)O(n^2)
    
- **Facilidad de Implementación**: Es fácil de entender e implementar, lo que lo hace útil para propósitos educativos.
- **Estabilidad**: Es un algoritmo estable, lo que significa que preserva el orden relativo de los elementos iguales.

Codigo en C:

```c
#include <stdio.h>

// Function to swap two elements
void swap(int* xp, int* yp) {
    int temp = *xp;
    *xp = *yp;
    *yp = temp;
}

// Function to implement bubble sort
void bubble_sort(int arr[], int n) {
    int i, j;
    int swapped;
    for (i = 0; i < n-1; i++) {
        swapped = 0;
        for (j = 0; j < n-i-1; j++) {
            if (arr[j] > arr[j+1]) {
                swap(&arr[j], &arr[j+1]);
                swapped = 1;
            }
        }
        // If no two elements were swapped in the inner loop, break
        if (swapped == 0)
            break;
    }
}

// Function to print an array
void print_array(int arr[], int size) {
    int i;
    for (i = 0; i < size; i++)
        printf("%d ", arr[i]);
    printf("\n");
}
```

### Ventajas:

- Muy fácil de implementar y entender.
- Puede ser eficiente para arrays muy pequeños o casi ordenados.

### Desventajas:

- Es ineficiente para arrays grandes debido a su complejidad O(n2).
    
    O(n2)O(n^2)
    
- Realiza muchas comparaciones y swaps innecesarios.

# Binary search

### Funcionamiento del Binary Search:

1. **Requisitos Previos**:
    - El array debe estar previamente ordenado.
2. **División del Rango**:
    - Se establece un rango de búsqueda inicial, que comprende el índice más bajo (`low`) y el índice más alto (`high`) del array.
3. **Cálculo del Punto Medio**:
    - El punto medio (`mid`) se calcula como (low+high)/2.
        
        (low+high)/2(low + high) / 2
        
4. **Comparación con el Punto Medio**:
    - Si el elemento buscado es igual al elemento en el punto medio, la búsqueda se detiene y se devuelve la posición del elemento.
    - Si el elemento buscado es menor que el elemento en el punto medio, la búsqueda se restringe a la mitad izquierda del rango.
    - Si el elemento buscado es mayor, la búsqueda se restringe a la mitad derecha.
5. **Repetición**:
    - Este proceso se repite hasta que el elemento es encontrado o el rango de búsqueda se reduce a cero.

### Características del Binary Search:

- **Complejidad Temporal**: Tiene una complejidad de tiempo de O(logn), lo que lo hace mucho más eficiente que la búsqueda lineal en grandes conjuntos de datos.
    
    O(log⁡n)O(\log n)
    
- **Restricciones**: Requiere que el array esté ordenado antes de la búsqueda.

En el lenguaje de la materia:
```c
{Pre: 1 <= lft <= n+1 && 0 <= rgt <= n && a ordenado}
fun binary_search_rec (a:array[1..n] of T, x:T, lft, rgt: nat) ret i:nat
		var mid: nat
		if lft > rgt then
				i:= 0
		else if lft <= rgt then
				mid:= (lft+rgt)/2
				if x < a[mid] then
						i:= binary_search_rec(a, x, lft, mid-1)
				else if x = a[mid] then
						i:= mid
				else if x > a[mid] then
						i:= binary_search_rec(a, x, mid+1, rgt)
				fi
		fi
end fun
{Post: (i = 0 => x no esta en a[lft, rgt]) && (i != 0 => x = a[i]}

{Pre: n >= 0}
fun binary_search (a:array[1..n] of T, x:T) ret i:nat
		i:= binary_search_rec(a, x, 1, n)
end fun
{Post: (i = 0 => x no esta en a) && (i != 0 => x = a[i]}
```

Codigo en C:

```c
#include <stdio.h>

int binary_search(int arr[], int size, int key) {
    int low = 0, high = size - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2;  // Calcula el punto medio

        // Verifica si el elemento está en el medio
        if (arr[mid] == key)
            return mid;

        // Si el elemento es menor que el medio, se ignora la mitad derecha
        if (arr[mid] > key)
            high = mid - 1;
        // Si el elemento es mayor que el medio, se ignora la mitad izquierda
        else
            low = mid + 1;
    }

    // Si el elemento no está presente
    return -1;
}
```

### Ventajas:

- Mucho más rápido que la búsqueda lineal para arrays grandes.
- La complejidad O(logn) lo hace adecuado para grandes conjuntos de datos.
    
    O(log⁡n)O(\log n)
    

### Desventajas:

- Requiere que el array esté ordenado antes de la búsqueda.
- No es útil para estructuras de datos desordenadas o listas no secuenciales.
