# Ordenación avanzada

# Merge sort

Merge Sort es un algoritmo de ordenamiento eficiente basado en la técnica "divide y vencerás". Se utiliza para ordenar listas dividiendo repetidamente la lista en mitades hasta que cada sublista tenga un solo elemento, y luego combinando las sublistas de manera ordenada.

Pasos de Merge Sort:

1. División:
    - Divide la lista en dos mitades iguales.
    - Repite este proceso recursivamente hasta que las sublistas contengan un solo elemento.
2. Conquista:
    - Comienza a combinar las sublistas en pares ordenados.
    - Al fusionar dos sublistas, se comparan los elementos de cada sublista y se colocan en orden en una nueva lista.
3. Combinación:
    - Fusiona las sublistas ordenadas para formar una lista completa ordenada.
    - Este proceso se repite hacia arriba hasta que todas las sublistas estén fusionadas en una sola lista ordenada.

![1000001072.png](Ordenacio%CC%81n%20avanzada%20eb708038761b4de5adff7bf580ccadec/1000001072.png)

En el lenguaje de la materia:

```c
proc merge(in/out a:array[1..n] of T, in lft,rgt: nat)
	var tmp: array[1..n] of T
	var j,k: nat
	// Copio los elementos del subarray izquierdo de a a tmp
	for i:= lft to mid do tmp[i]:=a[i] od 
	j:=lft // Inicio del subarray izquierdo
	k:=mid+1 // Inicio del subarray derecho
	for i:=lft to rgt do 
		if j <= mid && (k > rgt || tmp[j] <= a[k]) then
		     a[i]:= tmp[j]
		     j:= j+1
		else a[i]:=a[k]
   		     k:=k+1
		fi
	od
end proc

proc merge_sort_rec(in/out a:array[1..n] of T, in lft,rgt: nat)
	var mid: nat
	if rgt > lft --> mid:= (rgt+lft)/2
		merge_sort_rec(a, lft, mid) // Divido los subarray izquierdos
		merge_sort_rec(a, mid+1, rgt) // Divido los subarray derechos
		merge(a, lft, mid, rgt) // Mezcla los subarray ordenandolos
	fi
end proc

proc merge_sort(in/out a:array[1..n] of T)
	merge_sort_rec
end proc
```

En C:

```c
#include <stdio.h>
#include <stdlib.h>

void merge(int* a, int lft, int mid, int rgt) {
    int i, j, k;
    int n1 = mid - lft + 1;
    int n2 = rgt - mid;
    int* tmpL = (int*)malloc(n1 * sizeof(int));
    int* tmpR = (int*)malloc(n2 * sizeof(int));

    // Copy data to temporary arrays tmpL[] and tmpR[]
    for (i = 0; i < n1; i++)
        tmpL[i] = a[lft + i];
    for (j = 0; j < n2; j++)
        tmpR[j] = a[mid + 1 + j];

    // Merge the temporary arrays back into a[lft..rgt]
    i = 0; // Initial index of first subarray
    j = 0; // Initial index of second subarray
    k = lft; // Initial index of merged subarray
    while (i < n1 && j < n2) {
        if (tmpL[i] <= tmpR[j]) {
            a[k] = tmpL[i];
            i++;
        } else {
            a[k] = tmpR[j];
            j++;
        }
        k++;
    }

    // Copy the remaining elements of tmpL[], if any
    while (i < n1) {
        a[k] = tmpL[i];
        i++;
        k++;
    }

    // Copy the remaining elements of tmpR[], if any
    while (j < n2) {
        a[k] = tmpR[j];
        j++;
        k++;
    }

    free(tmpL);
    free(tmpR);
}

void merge_sort_rec(int* a, int lft, int rgt) {
    if (lft < rgt) {
        int mid = lft + (rgt - lft) / 2;

        // Recursively sort the two halves
        merge_sort_rec(a, lft, mid);
        merge_sort_rec(a, mid + 1, rgt);

        // Merge the sorted halves
        merge(a, lft, mid, rgt);
    }
}

void merge_sort(int* a, int n) {
    merge_sort_rec(a, 0, n - 1);
}
```

# Quick sort

### Funcionamiento del Quick Sort:

1. **Elección del Pivote**:
    - Se elige un elemento del array como **pivote**. El pivote puede ser el primer elemento, el último, uno aleatorio, o incluso el elemento medio del array.
2. **Partición**:
    - El array se reorganiza de manera que todos los elementos menores que el pivote se colocan a su izquierda, y todos los elementos mayores a su derecha.
    - Esto genera dos subarrays: uno con elementos menores que el pivote y otro con elementos mayores.
3. **Ordenación Recursiva**:
    - Recursivamente se aplica el mismo proceso a los subarrays izquierdo y derecho.
    - Este proceso continúa hasta que cada subarray tiene un solo elemento o está vacío, momento en el cual el array completo estará ordenado.

En el lenguaje de la materia:

```c
proc quick_sort_rec(in/out a:array[1..n] of T, in lft,rgt: nat)
	var ppiv: nat
	if rgt > lft -> partition(a, lft, rgt, ppiv)
		quick_sort_rec(a, lft, ppiv-1)
		quick_sort_rec(a, ppiv+1, rgt)
	fi
end proc

proc partition(in/out a:array[1..n] of T, in lft,rgt: nat, out ppiv: nat)
	var i,j: nat
	ppiv:= lft
	i:= lft+1
	j:= rgt
	do i <= j -> if a[i] <= a[ppiv] -> i:= i+1
			a[j] >= a[ppiv] -> j:= j-1
			a[i] > a[ppiv] && a[j] < a[ppiv] -> swap(a,i,j)											    		    i:= i+1
							    j:= j+1
		     fi
	od
	swap(a,ppiv,j)
	ppiv:= j
end proc

proc quick_sort(in/out a:array[1..n] of T)
	quick_sort_rec(a, 1, n)
end proc
```

En C:

```c
#include <stdio.h>

void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int partition(int a[], int low, int high) {
    int pivot = a[high]; // pivot
    int i = (low - 1);   // Index of smaller element

    for (int j = low; j <= high - 1; j++) {
        // If the current element is smaller than or equal to pivot
        if (a[j] <= pivot) {
            i++; // Increment index of smaller element
            swap(&a[i], &a[j]);
        }
    }
    swap(&a[i + 1], &a[high]);
    return (i + 1);
}

void quick_sort(int a[], int low, int high) {
    if (low < high) {
        // pi is partitioning index, a[pi] is now at right place
        int pi = partition(a, low, high);

        // Separately sort elements before
        // partition and after partition
        quick_sort(a, low, pi - 1);
        quick_sort(a, pi + 1, high);
    }
}
```
